[{"categories":null,"content":" 文章封面, 由作者通过 Canva 网站制作 在用 Matplotlib 绘制等值线图时，经常要在等值线上打上标签，表示这条线的数值是多少。 ","date":"2023-07-22","objectID":"/20230722/:0:0","tags":null,"title":"Matplotlib 等值线标签位置","uri":"/20230722/"},{"categories":null,"content":"默认打标签 默认情况下，Matplotlib 会根据实际情况自动标注标签，但是这样的标签位置比较分散。 比如下面这个代码： # -*- coding: utf-8 -*- import numpy as np import matplotlib.cm as cm import matplotlib.pyplot as plt # 创建等值线数据 delta = 0.025 x = np.arange(-3.0, 3.0, delta) y = np.arange(-2.0, 2.0, delta) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 fig = plt.figure(figsize=(16, 9)) ax = fig.add_subplot(111) # 等值线 LEVEL levels = np.arange(-1, 1.8, 0.1) # 绘制等值线 CS = ax.contour(Z, levels, linewidths=2, colors=\"black\") # 打标签 ax.clabel(CS, inline=True, fontsize=20) ax.set_title('contour clabel demo') fig.savefig(\"test.png\", dpi=200, bbox_inches='tight') 这样画出的图效果是这样： ","date":"2023-07-22","objectID":"/20230722/:0:1","tags":null,"title":"Matplotlib 等值线标签位置","uri":"/20230722/"},{"categories":null,"content":"自定义打标签 如果我们想自定义标签的位置该怎么做呢？其实 Matplotlib 自带了交互式的打标签功能。 只要设置 clabel 的 参数 manual=True 就可以了。 修改后代码如下： # -*- coding: utf-8 -*- import numpy as np import matplotlib.cm as cm import matplotlib.pyplot as plt # 创建等值线数据 delta = 0.025 x = np.arange(-3.0, 3.0, delta) y = np.arange(-2.0, 2.0, delta) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 fig = plt.figure(figsize=(16, 9)) ax = fig.add_subplot(111) # 等值线 LEVEL levels = np.arange(-1, 1.8, 0.1) # 绘制等值线 CS = ax.contour(Z, levels, linewidths=2, colors=\"black\", manual=True) # 修改 # 打标签 ax.clabel(CS, inline=True, fontsize=20) ax.set_title('contour clabel demo') fig.savefig(\"test.png\", dpi=200, bbox_inches='tight') 再次执行代码后，控制台会这样提示： Select label locations manually using first mouse button. End manual selection with second mouse button. 也就是说，鼠标左键可以点标签，鼠标中键保存图片。 注： 如果你绘制的是气象图，控制台还会多一句： Remove last label by clicking third mouse button. 也就是鼠标右键撤销上一步操作。 然后会自动弹出一个交互式的图像预览窗口，我们可以自行放大缩小图像，用鼠标在等值线上打标签。当你觉得标签的位置已经很满意时，按鼠标中键，图像就自动保存了。 用这个方法，就可以自定义标签的位置了。 ","date":"2023-07-22","objectID":"/20230722/:0:2","tags":null,"title":"Matplotlib 等值线标签位置","uri":"/20230722/"},{"categories":null,"content":"视频讲解 ","date":"2023-07-22","objectID":"/20230722/:0:3","tags":null,"title":"Matplotlib 等值线标签位置","uri":"/20230722/"},{"categories":null,"content":" 文章封面, 由作者通过 Canva 网站制作 到目前为止，我接触到的气象相关数据有等经纬度网格数据和站点数据。 注：为叙述简便，等经纬度网格数据以下简称网格数据。 下表为下文代码中用到数据的下载来源。 数据名称 下载来源 站点数据 https://cds.climate.copernicus.eu/#!/search?text=ERA5\u0026type=dataset，搜索station 网格数据 https://cds.climate.copernicus.eu/#!/search?text=ERA5\u0026type=dataset 站点数据就是个二维数据表，一般是 CSV 或者其他文本格式，这里我使用 test_station.csv1 文件。 通常用 Pandas 读取： import pandas as pd df = pd.read_csv(\"test_station.csv\", sep=\",\", encoding=\"utf-8\", comment=\"#\") print(df.columns) df = df[[\"latitude\", \"longitude\", \"total_column_water_vapour\"]] df.columns = [\"lat\", \"lon\", \"value\"] print(df) 结构就像这样： Index(['report_id', 'station_name', 'city', 'organisation_name', 'latitude', 'longitude', 'sensor_altitude', 'height_of_station_above_sea_level', 'start_date', 'report_timestamp', 'total_column_water_vapour'], dtype='object') lat lon value 0 49.186825 -68.263330 12.88 1 51.192345 14.521734 30.69 2 47.907738 7.632879 29.42 3 48.380493 -4.496594 15.99 4 50.798060 4.358563 19.01 ... ... ... ... 9811 60.750510 -135.222100 14.09 9812 52.236870 -122.167810 19.11 9813 34.226120 -118.055916 13.35 9814 62.481323 -114.480840 15.52 9815 62.480892 -114.480705 15.57 [9816 rows x 3 columns] 其中 lat 表示纬度，lon 表示经度，val 表示站点观测值。 这个数据用 VSCode 简单预览是这样： 网格数据通常用 Xarray 读取，这里我使用 test_grid.nc2： import xarray as xr with xr.open_dataset(\"test_grid.nc\") as ds_nc: ds_nc = ds_nc.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_nc = ds_nc.isel(time=0)[\"t\"] # 用索引的方式选取首个 time 维度, 选取变量 t print(dr_nc) 结构就像这样： \u003cxarray.DataArray 't' (lat: 721, lon: 1440)\u003e [1038240 values with dtype=float32] Coordinates: * lon (lon) float32 0.0 0.25 0.5 0.75 1.0 ... 359.0 359.2 359.5 359.8 * lat (lat) float32 90.0 89.75 89.5 89.25 ... -89.25 -89.5 -89.75 -90.0 time datetime64[ns] 2020-07-01 Attributes: units: K long_name: Temperature standard_name: air_temperature 其中，lat 和 lon 是这个数据的两个维度，即纬度和经度，Coordinates 展示了这两个维度对应的坐标信息，Attributes 是一些属性信息，是个 Dict。 这个数据用 Panoply 简单预览是这样： 在实际使用过程中，经常会有这样的需求： 将网格数据插值到另一个坐标、分辨率不同的网格数据上 将网格数据插值到站点数据上 将站点数据插值到网格数据上 … 下面逐一说明。 ","date":"2023-05-29","objectID":"/20230529/:0:0","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将网格数据插值到另一个坐标、分辨率不同的网格数据上 我们这里再读取一个与 test_grid.nc 坐标不同的一个 grib2 格式的网格数据，test_grid.grib23： import xarray as xr with xr.open_dataset( \"test_grid.grib2\", engine=\"cfgrib\", backend_kwargs={ \"indexpath\":\"\", 'filter_by_keys':{ 'typeOfLevel':'surface', 'shortName':'t', 'level':0 } } ) as ds_grib2: ds_grib2 = ds_grib2.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_grib2 = ds_grib2[\"t\"] print(dr_grib2) 结构就像这样： \u003cxarray.DataArray 't' (lat: 181, lon: 360)\u003e [65160 values with dtype=float32] Coordinates: time datetime64[ns] ... step timedelta64[ns] ... surface float64 ... * lat (lat) float64 90.0 89.0 88.0 87.0 ... -87.0 -88.0 -89.0 -90.0 * lon (lon) float64 0.0 1.0 2.0 3.0 4.0 ... 356.0 357.0 358.0 359.0 valid_time datetime64[ns] ... Attributes: (12/29) GRIB_paramId: 130 GRIB_dataType: fc GRIB_numberOfPoints: 65160 GRIB_typeOfLevel: surface GRIB_stepUnits: 1 GRIB_stepType: instant ... ... GRIB_name: Temperature GRIB_shortName: t GRIB_units: K long_name: Temperature units: K standard_name: air_temperature 用 Panoply 预览是这样： 可以看到 test_grid.nc 的经纬度坐标为 (lon: 1440, lat: 721)，test_grid.grib2 的经纬度坐标为 (lat: 181, lon: 360)，是不一样的。 如果我们想得到 test_grid.nc 在 test_grid.grib2 的坐标上对应的值，只要将前者插值到 test_grid.grib2 上就可以了，代码如下： import xarray as xr with xr.open_dataset(\"test_grid.nc\") as ds_nc: ds_nc = ds_nc.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_nc = ds_nc.isel(time=0)[\"t\"] # 用索引的方式选取首个 time 维度, 选取变量 t with xr.open_dataset( \"test_grid.grib2\", engine=\"cfgrib\", backend_kwargs={ \"indexpath\":\"\", 'filter_by_keys':{ 'typeOfLevel':'surface', 'shortName':'t', 'level':0 } } ) as ds_grib2: ds_grib2 = ds_grib2.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_grib2 = ds_grib2[\"t\"] dr_nc_interp = dr_nc.interp(lat=dr_grib2.lat, lon=dr_grib2.lon) # 将 nc 插值到 grib2 的坐标上 print(dr_nc_interp) dr_nc_interp.to_netcdf(\"test_grid_interp.nc\") # 将插值后的数据导出成 nc 插值后的数据预览如下： \u003cxarray.DataArray 't' (lat: 181, lon: 360)\u003e array([[254.54649353, 254.54649353, 254.54649353, ..., 254.54649353, 254.54649353, 254.54649353], [252.3180542 , 252.36672974, 252.41772461, ..., 252.17819214, 252.2230072 , 252.2701416 ], [249.42973328, 249.46296692, 249.50082397, ..., 249.34706116, 249.3717804 , 249.39805603], ..., [234.89929199, 234.8343811 , 234.77180481, ..., 235.0947876 , 235.02911377, 234.96342468], [235.33354187, 235.33818054, 235.34359741, ..., 235.31808472, 235.32427979, 235.3289032 ], [235.04379272, 235.04379272, 235.04379272, ..., 235.04379272, 235.04379272, 235.04379272]]) Coordinates: time datetime64[ns] 2020-07-01 * lat (lat) float64 90.0 89.0 88.0 87.0 ... -87.0 -88.0 -89.0 -90.0 * lon (lon) float64 0.0 1.0 2.0 3.0 4.0 ... 356.0 357.0 358.0 359.0 step timedelta64[ns] 00:00:00 surface float64 0.0 valid_time datetime64[ns] 2016-10-06 Attributes: units: K long_name: Temperature standard_name: air_temperature 用 Panoply 查看插值后的数据，可以看到数据分布和 test_grid.nc 是一样的，但是这两个数据的坐标是不一样的。 ","date":"2023-05-29","objectID":"/20230529/:0:1","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将网格数据插值到站点数据上 将二维的站点数据转为三维的网格数据 这里我写了两种方式，一种是直接 for 循环填充数据，当数据量较大时速度很慢；一种是用 Pandas 的内置方法，性能较好。 import time import pandas as pd import numpy as np import xarray as xr def d1_to_d2_low(df_ori: pd.DataFrame, nan_val=np.nan): \"\"\"将 flatten 后的二维数据转为三维网格数据, 慢速版本 Args: df_ori(pd.DataFrame): 二维数据 nan_val(any): 缺测值, 默认为 np.nan Returns: (xr.DataDrray): 转换后的数据 \"\"\" lat_ser = df_ori[\"lat\"].drop_duplicates().sort_values() lat_ser.index = range(len(lat_ser)) lon_ser = df_ori[\"lon\"].drop_duplicates().sort_values() lon_ser.index = range(len(lon_ser)) empty = pd.DataFrame( data=np.full((len(lat_ser), len(lon_ser)), fill_value=nan_val) ) lat_ser_list = list(lat_ser.values) lon_ser_list = list(lon_ser.values) lat_list = df_ori[\"lat\"].to_list() lon_list = df_ori[\"lon\"].to_list() for idx, val in enumerate(df_ori[\"value\"].to_list()): lat_idx = lat_ser_list.index(lat_list[idx]) lon_idx = lon_ser_list.index(lon_list[idx]) empty.iloc[lat_idx, lon_idx] = val dr = xr.DataArray(empty, dims=(\"lat\", \"lon\"), coords={\"lat\": lat_ser, \"lon\": lon_ser}) xr.Dataset({\"data\":dr}).to_netcdf(\"station_grid.nc\") return dr def d1_to_d2_fast(df_ori: pd.DataFrame, is_save: bool=True): \"\"\"将 flatten 后的二维数据转为三维网格数据, 快速版本 Args: df_ori(pd.DataFrame): 二维数据 is_save(bool): 是否导出为 NC Returns: (xr.DataDrray): 转换后的数据 \"\"\" lat_ser = df_ori[\"lat\"].drop_duplicates().sort_values() lat_ser.index = range(len(lat_ser)) lon_ser = df_ori[\"lon\"].drop_duplicates().sort_values() lon_ser.index = range(len(lon_ser)) LAT, LON = np.meshgrid(np.array(lat_ser), np.array(lon_ser)) df_flatten = np.vstack((LAT.flatten(), LON.flatten())).T df_mod = pd.DataFrame(data=df_flatten, columns=[\"lat\", \"lon\"]) df_mod[\"value\"] = np.nan df_merged = pd.merge(df_ori, df_mod, on=[\"lat\", \"lon\"], how=\"outer\").sort_values([\"lat\", \"lon\"]) df_merged.index = range(len(df_merged)) df_merged[\"value\"] = df_merged[\"value_x\"] df_merged = df_merged[[\"lat\", \"lon\", \"value\"]] grid = np.array(df_merged[\"value\"]).reshape((len(lat_ser), len(lon_ser)), order=\"C\") # C: 最里面的轴开始读写，F: 从最外面的轴开始读写 dr = xr.DataArray(grid, dims=(\"lat\", \"lon\"), coords={\"lat\": lat_ser, \"lon\": lon_ser}) if is_save: xr.Dataset({\"data\":dr}).to_netcdf(\"station_grid.nc\") return dr df = pd.read_csv(\"test_station.csv\", sep=\",\", encoding=\"utf-8\", comment=\"#\")\\ .drop_duplicates(subset=[\"latitude\", \"longitude\"], keep=\"first\")\\ .reset_index() df = df[[\"latitude\", \"longitude\", \"total_column_water_vapour\"]] df.columns = [\"lat\", \"lon\", \"value\"] start1 = time.time() r1 = d1_to_d2_low(df) print(time.time() - start1) # 0.03896808624267578 start2 = time.time() r2 = d1_to_d2_fast(df) print(time.time() - start2) # 0.10771322250366211 执行代码后生成的 station_grid.nc 就是二维的站点数据转为三维的网格数据。 这一步骤不是必须的，只是为了能直观的用 Panoply 快速查看站点数据的分布情况。当然你也可以用 Matplotlib 绘制站点数据的散点图。 代码最后注释标出的快速版的时间比慢速版的还要慢，这是正常的，这是因为示例数据数据量较少。当数据量很大，数据精度很高时，耗时的区别就非常明显了，可以自行尝试。 注：站点数据要保证同一经纬度是唯一的，这里的示例数据因为源数据有其他维度，所以同一经纬度的数据不唯一，我在读取的时候手动去重了。 这个数据用 Panoply 预览是这样： 将网格数据插值到站点数据 完成这个步骤的常规方法是逐行读取站点数据，然后将每个站点插值到 test_nc 上： import xarray as xr import numpy as np import pandas as pd with xr.open_dataset(\"test_grid.nc\") as ds_nc: ds_nc = ds_nc.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_nc = ds_nc.isel(time=0)[\"t\"] # 用索引的方式选取首个 time 维度, 选取变量 t # 遍历站点数据，逐个点插值 data_interp = [] for idx, row in df.iterrows(): _lat, _lon, _val = row data_interp.append([_lat, _lon, dr_nc.interp(lat=_lat, lon=_lon)]) df_nc_interp = pd.DataFrame(data_interp, columns=[\"lat\", \"lon\", \"value\"]) dr_nc_to_station = d1_to_d2_fast(df_nc_interp) xr.Dataset({\"data\":dr_nc_to_station}).to_netcdf(\"dr_nc_to_station.nc\") 得出的 df_nc_interp 就是插值后的数据，dr_nc_to_station.nc 是用上面的方法将其转成了三维网格。用 Panoply 预览如下： 可以想见，这种方式性能也比较一般，当站点数据很多是，逐一循环速度很慢。 我们可以用 Scipy 的插值方法一次性得到所有的插值结果： import time import xarray as xr import numpy as np import pandas as pd import scipy.interpolate as interpolate def grid_to_station_low(station_df: pd.DataFrame, grid_dr: xr.DataArray): \"\"\"三维格点转插值到二维站点, 慢速 Args: station_df(pd.DataFrame): 站点数据 grid_dr: 格点数据 Returns: (pd.DataFrame): 插值后的数据 \"\"\" # 遍历站点数据，逐个点插值 data_","date":"2023-05-29","objectID":"/20230529/:0:2","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将站点数据插值到网格数据上（反距离权重插值） 还会有一种需求，是将站点数据插值到指定精度的网格上。 原本为 NAN 的数据要运用反距离权重插值预测出对应的值，而反距离权重插值简单讲就是要预测的点的值取决于距离它最近的点。 与它距离越近，对它的影响就越大。 反距离权重插值需要安装 wradlib 库，用 Conda 可以直接安装： conda install wradlib -c conda-forge -y 这里直接给出代码： import numpy as np import pandas as pd import xarray as xr import wradlib.ipol as ipol # 目标网格精度 nx, ny = 300, 300 # 站点数据 df = pd.read_csv(\"test_station.csv\", sep=\",\", encoding=\"utf-8\", comment=\"#\")\\ .drop_duplicates(subset=[\"latitude\", \"longitude\"], keep=\"first\")\\ .reset_index() df = df[[\"latitude\", \"longitude\", \"total_column_water_vapour\"]] df.columns = [\"lat\", \"lon\", \"value\"] data_lon, data_lat, data_val = df[\"lon\"], df[\"lat\"], df[\"value\"] vals = data_val.values src = np.vstack((data_lon, data_lat)).transpose() # 生成目标经纬度坐标 range_lon = [round(i,2) for i in np.linspace(data_lon.min()-20, data_lon.max()+20, nx)] range_lat = [round(i,2) for i in np.linspace(data_lat.min()-20, data_lat.max()+20, ny)] # 生成目标经纬度网格 lon_lst, lat_lst = np.meshgrid(range_lon, range_lat) trg = np.vstack((lon_lst.ravel(), lat_lst.ravel())).T # IDW 插值 idw = ipol.Idw(src, trg) interpolated = idw(vals) grid = interpolated.reshape((len(range_lon), len(range_lat))) nc_interp = xr.DataArray(grid, dims=(\"lat\", \"lon\"), coords={\"lat\":range_lat, \"lon\":range_lon}) xr.Dataset({\"data\": nc_interp}).to_netcdf(\"station_to_grid.nc\") 插值后的 NC 数据预览如下，可以和上面的站点图像做对比： ","date":"2023-05-29","objectID":"/20230529/:0:3","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"视频讲解 ","date":"2023-05-29","objectID":"/20230529/:0:4","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"示例数据下载 test_station.csv ↩︎ test_grid.nc ↩︎ test_grid.grib2 ↩︎ ","date":"2023-05-29","objectID":"/20230529/:0:5","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":" 文章封面, 由作者通过 Canva 网站制作 ","date":"2023-05-26","objectID":"/20230527/:0:0","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"用 Matplotlib 绘制 pcolormesh 填色图 Matplotlib 的 pcolormesh 可以将二维数据绘制成填色图，可以一目了然地展示数据的分布情况。官方文档的 Demo 展示了这个函数的简单使用方式。 import matplotlib.pyplot as plt import numpy as np np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = plt.figure(figsize=(16, 9)) # 创建画布 ax = fig.add_subplot(111) img = ax.pcolormesh(x, y, Z, cmap=\"jet\") # 添加填色实例, 设置色标 ax.set_xticks(x) # 设置 x 轴坐标 ax.set_yticks(y) # 设置 y 轴坐标 fig.colorbar(img, ax=ax) # 添加色带 fig.savefig(\"00_test.png\", bbox_inches='tight') # 执行绘图并导出成图片 生成的 Z 数据如下，形状为 6 行 10 列： 0 1 2 3 4 5 6 7 8 9 0 0.700367 0.742751 0.70928 0.566746 0.977785 0.706335 0.247916 0.157883 0.697699 0.719957 1 0.257744 0.341547 0.968761 0.694507 0.466383 0.702813 0.511786 0.928741 0.739769 0.622439 2 0.651545 0.396808 0.543239 0.7999 0.721545 0.295364 0.160946 0.206126 0.134325 0.480605 3 0.342522 0.362969 0.972918 0.110944 0.388264 0.783066 0.972897 0.48321 0.336421 0.567419 4 0.0479415 0.388937 0.906304 0.161018 0.743621 0.632974 0.32418 0.922377 0.237226 0.823946 5 0.750607 0.113784 0.845361 0.923932 0.220837 0.933054 0.488999 0.474719 0.0891675 0.229948 绘制出的图片如下： Matplotlib pcolormesh Demo 从这张图中，结合右边的 Colorbar 我们可以清晰地看到数据的分布情况。 目前的 Colorbar 是像彩虹一样的渐变形式，色值分层也是默认的连续数值。我们可以做下面的修改，自定义色值分层，自定义每个区间的颜色，让 Colorbar 显示成「一格一格」的形式。 import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import BoundaryNorm, ListedColormap # 新增 np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = plt.figure(figsize=(16, 9)) # 创建画布 ax = fig.add_subplot(111) # 修改--- # 自定义色值 LEVEL LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9] # 自定义每个区间的颜色 cmap = ListedColormap([ '#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000', ]) # type: ignore norm = BoundaryNorm(LEVEL, ncolors=cmap.N, clip=True) img = ax.pcolormesh(x, y, Z, cmap=cmap, norm=norm) # 添加填色实例 ax.set_xticks(x) # 设置 x 轴坐标 ax.set_yticks(y) # 设置 y 轴坐标 fig.colorbar(img, ax=ax, ticks=LEVEL) # 添加色带 # --- fig.savefig(\"01_test.png\", dpi=200, bbox_inches='tight') # 执行绘图并导出成图片 Matplotlib pcolormesh 自定义 colorbar 可以看到，我们设置的 LEVEL 并不是连续的数值，但每个色块显示的长度都是相同的。由此我们可以很灵活地根据业务需要去调整 Colorbar，画出我们想要的图。 ","date":"2023-05-26","objectID":"/20230527/:0:1","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"用 Plotly 绘制 Heatmap 填色图 Matplotlib 画出的图都是静态的图片，如果我们想实时看到图中每个方格里的实际值是多少，该怎么做呢？ 有很多库可以绘制交互式的图表，既可以生成 HTML 网页，也可以实时在 Jupyter Notebook 中展示，本文介绍 Plotly 的使用。 与 pcolormesh 效果对应的就是 Heatmap，上文中的第一个 Demo 实现出来是这种效果： 绘图代码如下： import plotly.graph_objects as go import numpy as np np.random.seed(1) np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = go.Figure(data=go.Heatmap( z=Z, x=x, y=y, colorscale='jet' ) ) fig.update_layout( title='Plotly Heatmap Demo', xaxis=dict(tickvals=x, ticktext=x, title=\"X Axis\"), yaxis=dict(tickvals=y, ticktext=y, title=\"Y Axis\"), ) fig.write_json(\"02_test.html\") 这便是 Plotly 画出的交互图，把鼠标放上去可以看到每个方格的具体数值，并且可以自由放大、缩小，以及将图表保存成图片下载等等。 可以注意到这个图的 Colorbar 也是连续的彩虹状，而这个图要自定义 LEVEL 就不像 Matplotlib 那样简单了，两个库的实现思路完全不同。 这里给出实现的代码： import plotly.graph_objects as go import numpy as np import pandas as pd def trans_data(level: list, colors: list): \"\"\"转换数据 Args: level(list): 自定义层级列表 colors(list): 自定义颜色列表, 长度应比 level 小 1 Returns: (tuple): 分组转换后的数据 区间值列表 色标分层列表 \"\"\" assert len(colors) + 1 == len(level), \"colors 长度应比 level 小 1\" labels = np.arange(len(LEVEL)+1) ratio_list = np.linspace(0, 1, len(color_list)+1).tolist() colorscale_list = [[ratio_list[0], color_list[0]]] for idx, _ in enumerate(color_list[1:]): colorscale_list.append([ratio_list[idx+1], color_list[idx]]) colorscale_list.append([ratio_list[idx+1], color_list[idx+1]]) colorscale_list.append([ratio_list[-1], color_list[-1]]) Z_cut = pd.DataFrame(pd.cut( Z.flatten(), bins=[-np.infty] + LEVEL + [np.infty], labels=labels ).reshape(Z.shape)) return Z_cut, labels, colorscale_list np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9] color_list = ['#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000'] Z_cut, labels, colorscale_list = trans_data(LEVEL, color_list) Z_cut_values = np.unique(Z_cut.values.flatten()) fig = go.Figure(data=go.Heatmap( z=Z_cut, x=x, y=y, colorbar=dict( tickvals=np.arange(Z_cut_values.min(), Z_cut_values.max()+1), ticktext=LEVEL ), colorscale=colorscale_list, customdata=Z, hovertemplate='x: %{x}\u003cbr\u003ey: %{y}\u003cbr\u003ez: %{customdata}\u003cextra\u003e\u003c/extra\u003e', ) ) fig.update_layout( title='Plotly Heatmap Demo', xaxis=dict(tickvals=x, ticktext=x, title=\"X Axis\"), yaxis=dict(tickvals=y, ticktext=y, title=\"Y Axis\"), ) fig.write_html(\"03_test.html\") 图表效果是这样： ","date":"2023-05-26","objectID":"/20230527/:0:2","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"参考资料 Including plotly figures in Hugo posts ","date":"2023-05-26","objectID":"/20230527/:0:3","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"}]