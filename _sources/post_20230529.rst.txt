处理气象数据常用的插值方法
===========================

气象业务当中，比较常见的数据形式有 **站点数据** 和 **网格数据**  。

站点数据
---------------

**站点数据** 就是个二维数据表，一般是 CSV、TXT、或者 Excel 等格式，这里我们用一个 CSV 数据（ *UPA_obs.csv* [1]_ ）举例。

用 `Pandas`_ 读取：

.. _Pandas: https://docs.xarray.dev/en/stable/getting-started-guide/quick-overview.html

.. code-block:: python
    :linenos:

    import pandas as pd

    df = pd.read_csv("UPA_obs.csv", sep=",", encoding="utf-8")
    df = df[["latitude", "longitude", "temperature"]]
    df = df.dropna(subset=["latitude", "longitude"], how="any")
    df.index = range(len(df))
    df["temperature"] = df["temperature"].astype(float)
    df = df.rename(columns={"latitude": "lat", "longitude": "lon", "temperature": "value"})
    df

结构就像这样：

::

            lat         lon  value
    0    51.466667  -90.200000  -43.5
    1    51.466667  -90.200000  -53.9
    2    53.533333 -114.083333  -28.3
    3    53.533333 -114.083333  -53.5
    4    53.750000  -73.666667  -41.7
    ..         ...         ...    ...
    177  34.733333 -120.583333  -42.3
    178  40.900000 -117.800000  -16.8
    179  40.900000 -117.800000  -44.2
    180  46.466667  -84.366667  -39.1
    181  46.466667  -84.366667  -48.1

    [182 rows x 3 columns]

其中 ``lat`` 表示纬度， ``lon`` 表示经度， ``value`` 表示站点观测值。

把这个数据在地图上以打点的形式画出来，点的颜色对应数值大小：

.. figure:: /_images/20230529/00.png
   :alt: 站点数据打点

可以看到，这个数据内容是北美的气温数据，每个点的颜色代表了温度的大小，温度单位是摄氏度（℃）。
我们把温度的显示范围设定在了 -60 ~ -30 ℃ 之间，以便让各个颜色区域都有值。

画图脚本如下：

.. code-block:: python
    :linenos:

    # -*- coding: utf-8 -*-

    import numpy as np
    import pandas as pd
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter

    mpl.rcParams['font.sans-serif'] = ['Microsoft YaHei']
    mpl.rcParams['axes.unicode_minus'] = False

    # 读取数据
    df = pd.read_csv("UPA_obs.csv", sep=",", encoding="utf-8")
    df = df[["latitude", "longitude", "temperature"]]
    df = df.dropna(subset=["latitude", "longitude"], how="any")
    df.index = range(len(df))
    df["temperature"] = df["temperature"].astype(float)
    df = df.rename(columns={"latitude": "lat", "longitude": "lon", "temperature": "value"})
    # 计算经纬度范围
    lon_min, lon_max, lat_min, lat_max = df.lon.min(), df.lon.max(), df.lat.min(), df.lat.max()
    lon_buffer = abs(lon_max - lon_min) * 0.1
    lat_buffer = abs(lat_max - lat_min) * 0.1
    map_extent = [lon_min - lon_buffer, lon_max + lon_buffer, lat_min - lat_buffer, lat_max + lat_buffer]

    # 绘图
    proj = ccrs.PlateCarree()
    fig = plt.figure(figsize=(16, 9))
    ax = fig.add_subplot(111, projection=proj)

    cmap = mpl.colormaps.get_cmap('jet')
    img = ax.scatter(df.lon, df.lat, s=200, c=df.value, marker='.', cmap=cmap, transform=proj, vmax=-30, vmin=-60)

    # 设置绘图经纬度区域
    ax.set_extent(map_extent, crs=proj) # type: ignore

    # 添加海岸线、国界
    ax.add_feature(cfeature.COASTLINE.with_scale('50m'), edgecolor='black', linewidth=0.5)
    ax.add_feature(cfeature.BORDERS.with_scale('50m'), linestyle='-', edgecolor='black', linewidth=0.5)

    # 添加经纬度坐标
    ax.set_yticks(np.arange(map_extent[2], map_extent[3], 10).round(2), crs=proj)
    ax.set_xticks(np.arange(map_extent[0], map_extent[1], 10).round(2), crs=proj)
    lon_formatter = LongitudeFormatter(degree_symbol='', dateline_direction_label=True)
    lat_formatter = LatitudeFormatter(degree_symbol='')
    ax.yaxis.set_major_formatter(lat_formatter)
    ax.xaxis.set_major_formatter(lon_formatter)

    # 获取画布位置大小参数
    l, b, w, h = ax.get_position().bounds

    # 添加色带
    cax = plt.axes([l, b - h * 0.06 - 0, w, h * 0.02])  # type: ignore
    cb = fig.colorbar(img, cax=cax, ticks=None, orientation='horizontal', extend="both")
    cb.ax.tick_params(labelsize=15)
    cb.set_label(r"$^{\circ}$C", size=20)

    # 标题
    title = 'Station Temperature Distribution'
    ax.set_title(title, fontsize=18, loc="left")

    # 保存图片
    fig.savefig('test_plot.png', dpi=200, bbox_inches='tight')
    plt.cla()
    plt.close(fig)
    plt.close("all")


网格数据
----------------------

**网格数据** 通常用 `Xarray`_ 库读取，这里我们使用 *GFS_test.nc*  [2]_：

.. _Xarray: https://docs.xarray.dev/en/stable/getting-started-guide/quick-overview.html

.. code-block:: python
    :linenos:

    with xr.open_dataset("GFS_test.nc") as ds:
        ds = ds.assign_coords(lon=((ds.lon + 180) % 360 - 180)) # 将经度范围从[0, 360]转换为[-180, 180]
        dr = ds["Temperature_isobaric"]
        dr = dr.isel(time=0) # first time step
        dr = dr.sel(isobaric3=85000) # 850 hPa
        dr = dr - 273.15 # K to °C


结构就像这样：

::

    <xarray.DataArray 'Temperature_isobaric' (lat: 46, lon: 101)>
    [4646 values with dtype=float32]
    Coordinates:
        time       datetime64[ns] 2010-10-26T12:00:00
        isobaric3  float32 8.5e+04
      * lat        (lat) float32 65.0 64.0 63.0 62.0 61.0 ... 23.0 22.0 21.0 20.0
      * lon        (lon) float32 -150.0 -149.0 -148.0 -147.0 ... -52.0 -51.0 -50.0
    Attributes:
        long_name:  Temperature @ Isobaric surface
        units:      K

其中， ``lat`` 和 ``lon`` 是这个数据的两个维度，即纬度和经度， ``Coordinates`` 展示了这各个维度对应的坐标信息， 
``Attributes`` 是一些属性信息，是个 ``Dict`` 。可以看到这个气温数据的单位是开尔文（K）。

把这个数据用网格填色的方式画在地图上：

.. figure:: /_images/20230529/01.png
   :alt: 格点数据预览

画图脚本如下：

.. code-block:: python
    :linenos:

    # -*- coding: utf-8 -*-

    import numpy as np
    import pandas as pd
    import xarray as xr
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter

    mpl.rcParams['font.sans-serif'] = ['Microsoft YaHei']
    mpl.rcParams['axes.unicode_minus'] = False

    # 读取数据
    with xr.open_dataset("GFS_test.nc") as ds:
        ds = ds.assign_coords(lon=((ds.lon + 180) % 360 - 180)) # 将经度范围从[0, 360]转换为[-180, 180]
        dr = ds["Temperature_isobaric"]
        dr = dr.isel(time=0) # first time step
        dr = dr.sel(isobaric3=85000) # 850 hPa
        dr = dr - 273.15 # K to °C

    # 计算经纬度范围
    lon_min, lon_max, lat_min, lat_max = dr.lon.min(), dr.lon.max(), dr.lat.min(), dr.lat.max()
    lon_buffer = abs(lon_max - lon_min) * 0.0
    lat_buffer = abs(lat_max - lat_min) * 0.0
    map_extent = [lon_min - lon_buffer, lon_max + lon_buffer, lat_min - lat_buffer, lat_max + lat_buffer]

    # 绘图
    proj = ccrs.PlateCarree()
    fig = plt.figure(figsize=(16, 9))
    ax = fig.add_subplot(111, projection=proj)

    cmap = mpl.colormaps.get_cmap('jet')
    LON, LAT = np.meshgrid(dr.lon, dr.lat)
    img = ax.pcolormesh(LON, LAT, dr, cmap=cmap, transform=proj, alpha=1)

    # 设置绘图经纬度区域
    ax.set_extent(map_extent, crs=proj) # type: ignore

    # 添加海岸线、国界
    ax.add_feature(cfeature.COASTLINE.with_scale('50m'), edgecolor='black', linewidth=0.5)
    ax.add_feature(cfeature.BORDERS.with_scale('50m'), linestyle='-', edgecolor='black', linewidth=0.5)

    # 添加经纬度坐标
    ax.set_yticks(np.arange(map_extent[2], map_extent[3], 10).round(2), crs=proj)
    ax.set_xticks(np.arange(map_extent[0], map_extent[1], 10).round(2), crs=proj)
    lon_formatter = LongitudeFormatter(degree_symbol='', dateline_direction_label=True)
    lat_formatter = LatitudeFormatter(degree_symbol='')
    ax.yaxis.set_major_formatter(lat_formatter)
    ax.xaxis.set_major_formatter(lon_formatter)

    # 获取画布位置大小参数
    l, b, w, h = ax.get_position().bounds

    # 添加色带
    cax = plt.axes([l, b - h * 0.085, w, h * 0.03])  # type: ignore
    cb = fig.colorbar(img, cax=cax, ticks=None, orientation='horizontal', extend="both")
    cb.ax.tick_params(labelsize=15)
    cb.set_label(r"$^{\circ}$C", size=20)

    # 标题
    title = 'Grid Temperature Distribution'
    ax.set_title(title, fontsize=18, loc="left")

    # 保存图片
    fig.savefig('test_plot.png', dpi=200, bbox_inches='tight')
    plt.cla()
    plt.close(fig)
    plt.close("all")


在实际使用过程中，经常会有这样的需求：

-  将\ **网格数据**\ 插值到另一个分辨率不同的\ **网格坐标**\ 上
-  将\ **网格数据**\ 插值到\ **站点数据**\ 的坐标上
-  将\ **站点数据**\ 插值到\ **网格数据**\ 的坐标上
-  …

下面逐一说明。


将网格数据插值到另一个坐标、分辨率不同的网格坐标上
---------------------------------------------------------------

我们上面用到的 *GFS_test.nc* 的经纬度坐标 shape 为 ``(lon: 101, lat: 46)`` ，
lat 的数据范围是 [65, 20]，lon 的数据范围是 [-150, -50]， 分辨率是 1 度。
现在我们要将这个数据插值到一个分辨率是 0.1 度的网格坐标上，范围不变。

.. code-block:: python
    :linenos:

    with xr.open_dataset("GFS_test.nc") as ds:
        ds = ds.assign_coords(lon=((ds.lon + 180) % 360 - 180)) # 将经度范围从[0, 360]转换为[-180, 180]
        dr = ds["Temperature_isobaric"]
        dr = dr.isel(time=0) # first time step
        dr = dr.sel(isobaric3=85000) # 850 hPa
        dr = dr - 273.15 # K to °C

    # 分辨率为 0.1 度的网格
    new_lat = np.arange(dr.lat.min(), dr.lat.max()+0.1, 0.1)
    new_lon = np.arange(dr.lon.min(), dr.lon.max()+0.1, 0.1)
    dr = dr.interp(lat=new_lat, lon=new_lon) # 插值
    dr.to_netcdf("GFS_test_850hPa_Temperature_0.1deg.nc")

插值后的数据预览如下：

::

    <xarray.DataArray 'Temperature_isobaric' (lat: 451, lon: 1001)>
    Coordinates:
        time       datetime64[ns] 2010-10-26T12:00:00
        isobaric3  float32 8.5e+04
      * lat        (lat) float64 20.0 20.1 20.2 20.3 20.4 ... 64.7 64.8 64.9 65.0
      * lon        (lon) float64 -150.0 -149.9 -149.8 -149.7 ... -50.2 -50.1 -50.0

可以看到数据的分辨率已经变成 0.1 度了，那么我们把这个插值后的数据画在地图上：

.. figure:: /_images/20230529/02.png
   :alt: 插值加密后的网格数据预览

和之前的图相比，插值后的数据明显更密集，没有了原来的网格状，而是更加平滑的分布。

将网格数据插值到站点数据上
------------------------------------------

将二维的站点数据转为三维的网格数据
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这里我写了两种方式，一种是直接 for 循环填充数据，当数据量较大时速度很慢；
一种是用 Pandas 的内置方法，性能较好。

.. code-block:: python
    :linenos:

   import time
   import pandas as pd
   import numpy as np
   import xarray as xr


   def d1_to_d2_low(df_ori: pd.DataFrame, nan_val=np.nan):
       """将 flatten 后的二维数据转为三维网格数据, 慢速版本

       Args:
           df_ori(pd.DataFrame): 二维数据
           nan_val(any): 缺测值, 默认为 np.nan

       Returns:
           (xr.DataDrray): 转换后的数据
       """
       lat_ser = df_ori["lat"].drop_duplicates().sort_values()
       lat_ser.index = range(len(lat_ser))
       lon_ser = df_ori["lon"].drop_duplicates().sort_values()
       lon_ser.index = range(len(lon_ser))

       empty = pd.DataFrame(
           data=np.full((len(lat_ser), len(lon_ser)), fill_value=nan_val)
       )

       lat_ser_list = list(lat_ser.values)
       lon_ser_list = list(lon_ser.values)
       lat_list = df_ori["lat"].to_list()
       lon_list = df_ori["lon"].to_list()
       for idx, val in enumerate(df_ori["value"].to_list()):
           lat_idx = lat_ser_list.index(lat_list[idx])
           lon_idx = lon_ser_list.index(lon_list[idx])
           empty.iloc[lat_idx, lon_idx] = val


       dr = xr.DataArray(empty, dims=("lat", "lon"), coords={"lat": lat_ser, "lon": lon_ser})
       xr.Dataset({"data":dr}).to_netcdf("station_grid.nc")
       return dr


   def d1_to_d2_fast(df_ori: pd.DataFrame, is_save: bool=True):
       """将 flatten 后的二维数据转为三维网格数据, 快速版本
       
       Args:
           df_ori(pd.DataFrame): 二维数据
           is_save(bool): 是否导出为 NC

       Returns:
           (xr.DataDrray): 转换后的数据
       """
       lat_ser = df_ori["lat"].drop_duplicates().sort_values()
       lat_ser.index = range(len(lat_ser))
       lon_ser = df_ori["lon"].drop_duplicates().sort_values()
       lon_ser.index = range(len(lon_ser))

       LAT, LON = np.meshgrid(np.array(lat_ser), np.array(lon_ser))

       df_flatten = np.vstack((LAT.flatten(), LON.flatten())).T

       df_mod = pd.DataFrame(data=df_flatten, columns=["lat", "lon"])
       df_mod["value"] = np.nan

       df_merged = pd.merge(df_ori, df_mod, on=["lat", "lon"], how="outer").sort_values(["lat", "lon"])
       df_merged.index = range(len(df_merged))
       df_merged["value"] = df_merged["value_x"]

       df_merged = df_merged[["lat", "lon", "value"]]

       grid = np.array(df_merged["value"]).reshape((len(lat_ser), len(lon_ser)), order="C") # C: 最里面的轴开始读写，F: 从最外面的轴开始读写
       dr = xr.DataArray(grid, dims=("lat", "lon"), coords={"lat": lat_ser, "lon": lon_ser})
       if is_save:
           xr.Dataset({"data":dr}).to_netcdf("station_grid.nc")
       return dr

   df = pd.read_csv("test_station.csv", sep=",", encoding="utf-8", comment="#")\
       .drop_duplicates(subset=["latitude", "longitude"], keep="first")\
           .reset_index()
   df = df[["latitude", "longitude", "total_column_water_vapour"]]
   df.columns = ["lat", "lon", "value"]

   start1 = time.time()
   r1 = d1_to_d2_low(df)
   print(time.time() - start1) # 0.03896808624267578

   start2 = time.time()
   r2 = d1_to_d2_fast(df)
   print(time.time() - start2) # 0.10771322250366211

执行代码后生成的 *station_grid.nc*
就是二维的站点数据转为三维的网格数据。

**这一步骤不是必须的** ，只是为了能直观的用 Panoply 快速查看站点数据的分布情况。当然你也可以用 `Matplotlib`_ 绘制站点数据的散点图。

.. _Matplotlib: https://matplotlib.org/stable/gallery/misc/keyword_plotting.html#sphx-glr-gallery-misc-keyword-plotting-py

代码最后注释标出的快速版的时间比慢速版的还要慢，这是正常的，这是因为示例数据数据量较少。当数据量很大，数据精度很高时，耗时的区别就非常明显了，可以自行尝试。

   注：站点数据要保证同一经纬度是唯一的，这里的示例数据因为源数据有其他维度，所以同一经纬度的数据不唯一，我在读取的时候手动去重了。

这个数据用 Panoply 预览是这样：

.. figure:: /_images/20230529/04.png
   :alt: 站点数据转为三维网格数据预览

   站点数据转为三维网格数据预览


将网格数据插值到站点数据
^^^^^^^^^^^^^^^^^^^^^^^^

完成这个步骤的常规方法是逐行读取站点数据，然后将每个站点插值到 *test_nc*
上：

.. code-block:: python
    :linenos:

   import xarray as xr
   import numpy as np
   import pandas as pd

   with xr.open_dataset("GFS_test.nc") as ds_nc:
       ds_nc = ds_nc.rename({"latitude":"lat", "longitude":"lon"}) # 重命名维度名称
       dr_nc = ds_nc.isel(time=0)["t"] # 用索引的方式选取首个 time 维度, 选取变量 t

   # 遍历站点数据，逐个点插值
   data_interp = []
   for idx, row in df.iterrows():
       _lat, _lon, _val = row
       data_interp.append([_lat, _lon, dr_nc.interp(lat=_lat, lon=_lon)])

   df_nc_interp = pd.DataFrame(data_interp, columns=["lat", "lon", "value"])
   dr_nc_to_station = d1_to_d2_fast(df_nc_interp)

   xr.Dataset({"data":dr_nc_to_station}).to_netcdf("dr_nc_to_station.nc")

得出的 *df_nc_interp* 就是插值后的数据，\ *dr_nc_to_station.nc*
是用上面的方法将其转成了三维网格。用 Panoply 预览如下：

.. figure:: /_images/20230529/05.png
   :alt: 格点数据插值到站点，慢速

   格点数据插值到站点，慢速

可以想见，这种方式性能也比较一般，当站点数据很多是，逐一循环速度很慢。

我们可以用 `Scipy`_ 的插值方法一次性得到所有的插值结果：

.. _Scipy: https://matplotlib.org/stable/gallery/misc/keyword_plotting.html#sphx-glr-gallery-misc-keyword-plotting-py

.. code-block:: python
    :linenos:

   import time
   import xarray as xr
   import numpy as np
   import pandas as pd
   import scipy.interpolate as interpolate


   def grid_to_station_low(station_df: pd.DataFrame, grid_dr: xr.DataArray):
       """三维格点转插值到二维站点, 慢速

       Args:
           station_df(pd.DataFrame): 站点数据
           grid_dr: 格点数据

       Returns:
           (pd.DataFrame): 插值后的数据

       """
       # 遍历站点数据，逐个点插值
       data_interp = []
       for idx, row in station_df.iterrows():
           _lat, _lon, _val = row
           data_interp.append([_lat, _lon, grid_dr.interp(lat=_lat, lon=_lon)])

       df_nc_interp = pd.DataFrame(data_interp, columns=["lat", "lon", "value"])
       return df_nc_interp


   def grid_to_station_fast(station_df: pd.DataFrame, grid_dr: xr.DataArray):
       """三维格点转插值到二维站点, 快速

       Args:
           station_df(pd.DataFrame): 站点数据
           grid_dr: 格点数据

       Returns:
           (pd.DataFrame): 插值后的数据

       """
       grid_dr_lat, grid_dr_lon = np.meshgrid(grid_dr.lat, grid_dr.lon)
       grid_dr_points = np.transpose(np.array([grid_dr_lat.flatten(), grid_dr_lon.flatten()]))
       grid_dr_values = np.array(grid_dr.values).transpose().reshape(-1, 1)
       xi = (station_df.lat, station_df.lon)
       nc_interp_values = interpolate.griddata(
           grid_dr_points, grid_dr_values, xi, fill_value=np.nan, method='linear').squeeze()
       nc_interp_values = pd.Series(nc_interp_values)
       df_nc_interp = pd.DataFrame({"lat":df.lat, "lon":df.lon, "value":nc_interp_values})
       return df_nc_interp


   df = pd.read_csv("test_station.csv", sep=",", encoding="utf-8", comment="#")\
       .drop_duplicates(subset=["latitude", "longitude"], keep="first")\
           .reset_index()
   df = df[["latitude", "longitude", "total_column_water_vapour"]]
   df.columns = ["lat", "lon", "value"]

   with xr.open_dataset("GFS_test.nc") as ds_nc:
       ds_nc = ds_nc.rename({"latitude":"lat", "longitude":"lon"}) # 重命名维度名称
       dr_nc = ds_nc.isel(time=0)["t"] # 用索引的方式选取首个 time 维度, 选取变量 t


   start1 = time.time()
   interp_1 = grid_to_station_low(df, dr_nc)
   dr_nc_to_station_1 = d1_to_d2_fast(interp_1)
   xr.Dataset({"data":dr_nc_to_station_1}).to_netcdf("dr_nc_to_station_1.nc")
   print(time.time() - start1) # 2.5377440452575684

   start2 = time.time()
   interp_2 = grid_to_station_fast(df, dr_nc)
   dr_nc_to_station_2 = d1_to_d2_fast(interp_2)
   xr.Dataset({"data":dr_nc_to_station_2}).to_netcdf("dr_nc_to_station_2.nc")
   print(time.time() - start2) # 21.849611043930054

上面的 ``grid_to_station_fast``
函数就可以一次性得到所有插值后的值。和上面一样，因为示例数据量较少，快速的方法优势体现不明显，可以换用数据量大的实际数据自行尝试。

这两种方式得到的数据是一样的，画出的图预览效果也一样：

.. figure:: /_images/20230529/06.png
   :alt: 格点数据插值到站点，快速

   格点数据插值到站点，快速


将三维网格数据转为二维
^^^^^^^^^^^^^^^^^^^^^^

**这个步骤也不是必须的**\ ，仅用于需要的情况。

``Xarray``
有方便的方法可以将三维的网格数据直接转为类似站点数据格式的二维数据：

.. code-block:: python
    :linenos:

   import pandas as pd
   import xarray as xr

   with xr.open_dataset("GFS_test.nc") as ds_nc:
       ds_nc = ds_nc.rename({"latitude":"lat", "longitude":"lon"}) # 重命名维度名称
       dr_nc = ds_nc.isel(time=0)["t"] # 用索引的方式选取首个 time 维度, 选取变量 t

   dr_stack = dr_nc.stack(z=("lat", "lon"))
   df = pd.DataFrame(data={
       "lat":dr_stack.lat,
       "lon":dr_stack.lon,
       "value": dr_stack.values
   })
   # 或者
   # df = dr_nc.to_dataframe(name="value").reset_index()

   df.to_csv("d2_to_d1.csv", index=None)



将站点数据插值到网格数据上（反距离权重插值）
---------------------------------------------------------------

还会有一种需求，是将站点数据插值到指定精度的网格上。 
原本为 ``np.nan`` 的数据要运用反距离权重插值预测出对应的值。
反距离权重插值的原理，简单讲就是被预测的值由它附近的点决定，与它距离越近的点权重越大，对它的影响就越大。

这里整理了国家气象信息中心开发的 `meteva`_ 库中提供的代码：

.. _meteva: https://github.com/nmcdev/meteva/blob/master/meteva/base/fun/interpolating.py

.. code-block:: python
    :linenos:

    import math
    import pandas as pd
    import numpy as np
    import xarray as xr
    from scipy.spatial import cKDTree


    # 地球半径
    ER = 6371.229


    def lon_lat_to_cartesian(lon, lat, R=1):
        """
        经度纬度信息转换为直角坐标系

        calculates lon, lat coordinates of a point on a sphere with
        radius R
        """
        lon_r = np.radians(lon)
        lat_r = np.radians(lat)
        xyz = np.zeros((len(lon), 3))
        xyz[:, 0] = R * np.cos(lat_r) * np.cos(lon_r)
        xyz[:, 1] = R * np.cos(lat_r) * np.sin(lon_r)
        xyz[:, 2] = R * np.sin(lat_r)
        return xyz


    def grid_data(lon_min, lon_len, lon_res, lat_min, lat_len, lat_res, data=None):
        """
        返回一个DataArray，其维度信息和grid描述一致，数组里面的值为0.
        """
        # 通过起始经纬度和格距计算经纬度格点数
        lon = np.arange(lon_len) * lon_res + lon_min
        lat = np.arange(lat_len) * lat_res + lat_min
        if data is None:
            data = np.zeros((lat_len, lon_len))
        else:
            data = data.reshape(lat_len, lon_len)

        return xr.DataArray(
            data, 
            coords={
                'lat': lat, 'lon': lon},
            dims=['lat', 'lon']
        )


    def grd_info(vmin, vmax, vres):
        vlen = 1 + (vmax - vmin) / vres
        error = abs(round(vlen) - vlen)/vlen
        if (error > 0.01):
            vlen = int(math.ceil(vlen))
        else:
            vlen = int(round(vlen))
        return (vmin, vlen, vres)


    def interp_sg_idw(sta, lon_info, lat_info, effectR=1000, nearNum=8, decrease=2):
        """站点到格点IDW插值
        
        Args:
            sta(pd.Dataframe): 站点数据, lat, lon, data
            lon_info(tuple): 目标网格的经度信息, (起始经度, 结束经度, 分辨率)
            lat_info(tuple): 目标网格的纬度信息, (起始纬度, 结束纬度, 分辨率)
            effectR(float): 最大的插值半径, 单位km
            nearNum(int): 插值选择的临近站点的个数, nearNum =1时即为临近点插值
            decrease(int): 站点权重随距离幂次衰减，即 站点权重 = 1 /(距离 ** decrease), 其中decrease是幂函数的指数部分参数

        Returns:
            (xr.DataArray): 插值后的网格
        """
        lon_min, lon_len, lon_res = grd_info(*lon_info)
        lat_min, lat_len, lat_res = grd_info(*lat_info)
        xyz_sta = lon_lat_to_cartesian(sta['lon'].values, sta['lat'].values, R=ER)
        lon = np.arange(lon_len) * lon_res + lon_min
        lat = np.arange(lat_len) * lat_res + lat_min
        grid_lon, grid_lat = np.meshgrid(lon, lat)
        xyz_grid = lon_lat_to_cartesian(grid_lon.flatten(), grid_lat.flatten(), R=ER)
        tree = cKDTree(xyz_sta)
        # d,inds 分别是站点到格点的距离和id
        if nearNum > len(sta.index):
            nearNum = len(sta.index)
        d, inds = tree.query(xyz_grid, k=nearNum)
        if nearNum > 1:
            d += 1e-6
            w = 1.0 / d ** decrease
            input_dat = sta.values[:,-1]
            dat = np.sum(w * input_dat[inds], axis=1) / np.sum(w, axis=1)
            bg = grid_data(lon_min, lon_len, lon_res, lat_min, lat_len, lat_res)
            bg_dat = bg.values.flatten()
            dat = np.where(d[:, 0] > effectR, bg_dat, dat)
        else:
            input_dat = sta.iloc[:,-1].values
            dat = input_dat[inds]
            bg = grid_data(lon_min, lon_len, lon_res, lat_min, lat_len, lat_res)
            bg_dat = bg.values.flatten()
            dat = np.where(d[:] > effectR, bg_dat, dat)
        dat = dat.astype(np.float32)
        grd = grid_data(lon_min, lon_len, lon_res, lat_min, lat_len, lat_res, dat)
        return grd


    # 站点数据
    df = pd.read_csv("test_station.csv", sep=",", encoding="utf-8", comment="#")\
        .drop_duplicates(subset=["latitude", "longitude"], keep="first")\
            .reset_index()
    df = df[["latitude", "longitude", "total_column_water_vapour"]]
    df.columns = ["lat", "lon", "value"]
    nc_interp = interp_sg_idw(df, (-180, 180, 0.1), (-89, 89, 0.1), effectR=100000)
    xr.Dataset({"data": nc_interp}).to_netcdf("station_to_grid.nc")

插值后的 NC 数据预览如下，可以和刚才的站点图像做对比：

.. figure:: /_images/20230529/04.png
   :alt: 站点图像

   站点图像

.. figure:: /_images/20230529/07.png
   :alt: 站点IDW插值到网格

   站点IDW插值到网格


示例数据下载
---------------------

.. [1]
   `UPA_obs.csv <https://github.com/Unidata/MetPy/blob/main/staticdata/UPA_obs.csv>`__

.. [2]
   `GFS_test.nc <https://github.com/Unidata/MetPy/blob/main/staticdata/GFS_test.nc>`__

.. [3]
   `test_grid.grib2 <https://github.com/junsircoding/junsircoding.github.io/blob/main/storage/20230529/test_grid.grib2>`__
   

视频讲解
---------------------

`我在处理气象数据时常用到的插值方法`_

.. _我在处理气象数据时常用到的插值方法: https://www.bilibili.com/video/BV1iX4y147eT/
