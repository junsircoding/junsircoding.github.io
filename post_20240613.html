<!DOCTYPE html>
<html class="writer-html5" lang="en-US" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>用抓包的方式理解 TCP 协议 &mdash; junsircoding&#39;s blog  documentation</title>

















      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="canonical" href="https://junsircoding.github.io/post_20240613.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=cd149c8d"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="如何在你的 Sphinx 项目中加入 plotly 图表支持？" href="post_20231222.html" />
    <link rel="prev" title="微信 Linux 版上架 Flathub 商店" href="post_20240621.html" />

     
    <link rel="stylesheet" type="text/css" href="_static/css/custom.css">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4178487904865687"
     crossorigin="anonymous"></script>
    <meta name="google-adsense-account" content="ca-pub-4178487904865687">

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "kb72rmcxcn");
</script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="post_20240621.html">微信 Linux 版上架 Flathub 商店</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">用抓包的方式理解 TCP 协议</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="#osi">OSI 模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">编写代码实现 TCP 通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">用 Wireshark 抓包</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">报文颜色解释</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">报文内容解释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">三次握手建立连接</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id7">第一次握手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">第二次握手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">第三次握手</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">四次挥手断开连接</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">第一次挥手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">第二次挥手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">第三次挥手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">第四次挥手</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">参考资料</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="post_20231222.html">如何在你的 Sphinx 项目中加入 plotly 图表支持？</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20231221.html">常用的几个 AWK 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20231220.html">Matplotlib Axes 的位置参数到底如何设置？</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20230723.html">将 Vim 打造成轻量级的 IDE</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20230722.html">Matplotlib 等值线图自定义 label 标签位置</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20230529.html">气象数据的各种插值问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="post_20230527.html">用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">junsircoding's blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">用抓包的方式理解 TCP 协议</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tcp">
<h1>用抓包的方式理解 TCP 协议<a class="headerlink" href="#tcp" title="Link to this heading"></a></h1>
<figure class="align-default" id="id19">
<img alt="封面" src="_images/20240613_00.jpeg" />
<figcaption>
<p><span class="caption-text">封面</span><a class="headerlink" href="#id19" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="id1">
<h2>背景<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>程序员在求职的过程中，如果遇到侧重考察计算机网络基础的面试，几乎都会被问到是否理解 TCP 协议。工作快五年了，对这个问题我还是不太明白，这篇文章就尝试梳理一下这个问题。</p>
<p>首先不管是什么通信协议，其实都是在做一件事情，就是把信息从一端传输到另一端。比如我们用浏览器打开一篇博客，在这个场景中，浏览器是客户端，部署文章的服务器是服务端，我们要看到这篇文章，本质就是完成客户端和服务端之间基于网络的通信。</p>
</section>
<section id="osi">
<h2>OSI 模型<a class="headerlink" href="#osi" title="Link to this heading"></a></h2>
<p>要研究网络通信，首先得把经典的 OSI 七层模型搬出来。为了记忆这个模型我自创了一个顺口溜， <strong>物联网传话试用</strong> ，下面这个表格标明了它们的对应关系：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>简写</p></th>
<th class="head"><p>对应的 OSI 层</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>用</p></td>
<td><p>应用层</p></td>
</tr>
<tr class="row-odd"><td><p>试</p></td>
<td><p>表示层</p></td>
</tr>
<tr class="row-even"><td><p>话</p></td>
<td><p>会话层</p></td>
</tr>
<tr class="row-odd"><td><p>传</p></td>
<td><p>传输层</p></td>
</tr>
<tr class="row-even"><td><p>网</p></td>
<td><p>网络层</p></td>
</tr>
<tr class="row-odd"><td><p>联</p></td>
<td><p>数据链路层</p></td>
</tr>
<tr class="row-even"><td><p>物</p></td>
<td><p>物理层</p></td>
</tr>
</tbody>
</table>
<p>每一层都有一些工作在它们上面的通信协议，通信协议其实就是一种程序。当信息到达某一层时，对应的协议会按照其规则对信息进行处理，下面从低层到高层依次举例。</p>
<p><strong>物理层</strong> ：WIFI 协议。我们用设备连接无线网时，操作系统会调用 WIFI 驱动程序，让无线网卡连接到 WIFI 信号。</p>
<p><strong>数据链路层</strong> ：MAC 协议。MAC 协议规定每个网卡要有一个 MAC 地址。MAC 地址就是网卡的身份证号，表明了这张网卡是哪个厂子出的，对应的生产序列号是多少。理论上全世界网卡的 MAC 地址不会重复。</p>
<p><strong>网络层</strong> ：IP 协议。一个联网的设备，在网络的世界中一定得有一个地址，这就是 IP 地址。有了 IP 地址，这个设备才能给另一个设备发送信息，以及接收另一个设备发过来的信息。</p>
<p><strong>传输层</strong> ：TCP 协议，UDP 协议。有了 IP 地址，下面就可以开始通信了，但是因为通信的背景和需求各式各样，所以有很多不同特点的协议。</p>
<p>比如说打个视频电话，重要的是速度要快，实时性要保证，通话过程中缺个一两秒也可以接受，那么就可以用 UDP 协议。UDP 协议的特点就是速度快，但可能会因为网络信道不稳定而丢包。</p>
<p>再比如浏览网页，重要的是数据要完整，缺一点点东西可能全部的信息就乱了，响应慢一点也可以容忍，传输网页的 HTTP 报文就是 TCP 协议的。TCP 协议的特点是有一套可靠的建立连接和断开连接的机制，而且可以保证信息有序完整的传输，以及其他比较复杂的特性。即便网络信道不稳定，产生丢包，也有补救机制把缺失的数据重传补全。</p>
<p><strong>会话层、表示层、应用层</strong> 这三层可以打包看成一层，在研究网络传输的这个过程里面不需要分这么细。比如上面提到的 HTTP 协议，就是浏览网页时用到的协议。</p>
<p>我们网购收到的快递都是用一个个袋子装起来，然后袋子上面有个标签，上面写着由哪个公司投递、发件地址和收件地址等信息，这就类似于一个报文。报文由报头和载荷组成。报头表明这是一个什么报文以及其他的一些描述性的参数信息，载荷里面装着要发送的内容。</p>
<p>用专业术语讲，二层的数据叫 Frame（帧），三层的数据叫 Packet，四层的数据叫 Segment，但其实都可以理解成报文，只是读取它们所使用的协议不一样。</p>
<p>客户端和服务端进行通信，其实就是客户端创建了一个 HTTP 的报文，然后根据 TCP 协议把他打包成 TCP 的 Segment，然后又根据 IP 协议打包成 IP 的 Packet，IP 报文再变成网络 Frame，网络 Frame 再变成二进制的比特流，经由交换机、路由器等网络设备层层转发，到达服务端。</p>
<p>对于 TCP 的 Segment，它的报头表明这个报文的类型是 TCP，载荷里面装着 HTTP 报文，只不过它的内容对于 TCP 协议来说不重要，它也无法理解。</p>
<p>刚才的比特流信息凭借 IP 地址被正确转发到了服务端所在网络的网关，再凭借 MAC 地址被交换机转发给服务端主机的网卡上。网卡收到了比特流，还原成网络 Frame，操作系统将其还原成 IP Packet，再根据 IP 协议从里面提取出 TCP Segment，TCP Segment 又被交给绑定了对应端口的应用上，这个应用程序再根据 TCP 协议从里面提取出 HTTP 报文，然后根据 HTTP 协议解析出内容，交由对应的处理函数做处理，进而构造响应报文。处理完成后，再经由相同的流程，层层打包后，把响应信息返回给客户端。</p>
</section>
<section id="id2">
<h2>编写代码实现 TCP 通信<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>脑子里把这个过程加载完成后，就相当于有了一个知识的地图，那么现在再来讨论 TCP 协议，就能知道它在实际应用中是在什么样的场景下，完成了什么样的事情。</p>
<p>TCP 协议工作在传输层。根据控制变量原则，假设物理层、数据链路层、网络层都是没有问题的。会话层、表示层、应用层的信息我们尽量简化。在本地机器上用 Python 写一个 TCP 服务端和 TCP 客户端来实现一个 TCP 通信过程，然后用 <a class="reference external" href="https://www.wireshark.org/">Wireshark</a> 抓包来实际看一下 TCP 协议的实际工作过程。</p>
<p>TCP 客户端的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="linenos"> 2</span><span class="kn">import</span> <span class="nn">socket</span>
<span class="linenos"> 3</span><span class="c1"># 创建一个 socket 应用，使用 IPV4 和 TCP 协议</span>
<span class="linenos"> 4</span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="linenos"> 5</span><span class="c1"># 绑定 ip 地址为本地回环地址，5201 端口</span>
<span class="linenos"> 6</span><span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">5201</span><span class="p">))</span>
<span class="linenos"> 7</span><span class="c1"># 要连接的服务端 ip 为本地回环地址，端口为 5200</span>
<span class="linenos"> 8</span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">5200</span><span class="p">))</span>
<span class="linenos"> 9</span><span class="c1"># 当 TCP 连接成功建立后，打印服务端返回的信息</span>
<span class="linenos">10</span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
<span class="linenos">11</span><span class="c1"># 向服务端发送信息</span>
<span class="linenos">12</span><span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">b</span><span class="s2">&quot;user1&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;user2&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;user3&quot;</span><span class="p">]:</span>
<span class="linenos">13</span>    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="c1"># 打印服务端返回的信息</span>
<span class="linenos">15</span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
<span class="linenos">16</span><span class="c1"># 想服务端发动断开连接的消息</span>
<span class="linenos">17</span><span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;exit&quot;</span><span class="p">)</span>
<span class="linenos">18</span><span class="c1"># 客户端主动断开连接</span>
<span class="linenos">19</span><span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>TCP 服务端的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="linenos"> 2</span><span class="kn">import</span> <span class="nn">time</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">socket</span>
<span class="linenos"> 4</span><span class="kn">import</span> <span class="nn">threading</span>
<span class="linenos"> 5</span><span class="c1"># 创建一个 socket 应用，同样使用 IPV4 和 TCP 协议</span>
<span class="linenos"> 6</span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="linenos"> 7</span><span class="c1"># 绑定 ip 地址为本地回环地址，5200 端口</span>
<span class="linenos"> 8</span><span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">5200</span><span class="p">))</span>
<span class="linenos"> 9</span><span class="c1"># 开始监听请求，最多同时接受 5 个请求</span>
<span class="linenos">10</span><span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="linenos">11</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Server is running ...&quot;</span><span class="p">)</span>
<span class="linenos">12</span><span class="k">def</span> <span class="nf">tcplink</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
<span class="linenos">13</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Get a new connection, ip:</span><span class="si">%s</span><span class="s2">, port:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">addr</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello!&quot;</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="c1"># 解码接收到的信息</span>
<span class="linenos">17</span>        <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="linenos">18</span>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">19</span>        <span class="c1"># 如果接收到的信息是 exit，由服务端主动断开连接</span>
<span class="linenos">20</span>        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;exit&quot;</span><span class="p">:</span>
<span class="linenos">21</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got exit message, close the connection.&quot;</span><span class="p">)</span>
<span class="linenos">22</span>            <span class="k">break</span>
<span class="linenos">23</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got a data: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
<span class="linenos">24</span>        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="s2">&quot;Hi, </span><span class="si">%s</span><span class="s2">, I got you!&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
<span class="linenos">25</span>    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="linenos">26</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Close a connection, ip:</span><span class="si">%s</span><span class="s2">, port:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">addr</span><span class="p">)</span>
<span class="linenos">27</span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">28</span>    <span class="c1"># 收到一条请求，交由一个线程去处理</span>
<span class="linenos">29</span>    <span class="n">sock</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="linenos">30</span>    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tcplink</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
<span class="linenos">31</span>    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id3">
<h2>用 Wireshark 抓包<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<p>打开 Wireshark，准备抓包。</p>
<p>在上面的代码里，我们把客户端的端口设置成了 5201，服务端的端口是 5200。所以将筛选规则设置成这样：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>tcp<span class="w"> </span>port<span class="w"> </span><span class="m">5200</span><span class="w"> </span>or<span class="w"> </span>tcp<span class="w"> </span>port<span class="w"> </span><span class="m">5201</span>
</pre></div>
</div>
<p>捕获的网卡是本机的回环网卡，筛选规则是 TCP 协议，端口为 5200 和 5201，如下图所示：</p>
<figure class="align-default" id="id20">
<img alt="Wireshark 抓包筛选规则" src="_images/20240613_01.png" />
<figcaption>
<p><span class="caption-text">Wireshark 抓包筛选规则</span><a class="headerlink" href="#id20" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>点 Start，开始抓包。</p>
<p>先启动服务端：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>python3<span class="w"> </span>tcp_server.py
</pre></div>
</div>
<p>再启动客户端：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>python3<span class="w"> </span>tcp_client.py
</pre></div>
</div>
<p>服务端的运行日志是这样：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>Server<span class="w"> </span>is<span class="w"> </span>running<span class="w"> </span>...17:21:36:552048
<span class="linenos">2</span>Get<span class="w"> </span>a<span class="w"> </span>new<span class="w"> </span>connection,<span class="w"> </span>ip:127.0.0.1,<span class="w"> </span>port:5201,<span class="w"> </span><span class="m">17</span>:21:39:253209
<span class="linenos">3</span>Got<span class="w"> </span>a<span class="w"> </span>data:<span class="w"> </span>user1,<span class="w"> </span><span class="m">17</span>:21:40:254525
<span class="linenos">4</span>Got<span class="w"> </span>a<span class="w"> </span>data:<span class="w"> </span>user2,<span class="w"> </span><span class="m">17</span>:21:41:255906
<span class="linenos">5</span>Got<span class="w"> </span>a<span class="w"> </span>data:<span class="w"> </span>user3,<span class="w"> </span><span class="m">17</span>:21:42:257482
<span class="linenos">6</span>Got<span class="w"> </span><span class="nb">exit</span><span class="w"> </span>message,<span class="w"> </span>close<span class="w"> </span>the<span class="w"> </span>connection,<span class="w"> </span><span class="m">17</span>:21:43:258953
<span class="linenos">7</span>Close<span class="w"> </span>a<span class="w"> </span>connection,<span class="w"> </span>ip:127.0.0.1,<span class="w"> </span>port:5201,<span class="w"> </span><span class="m">17</span>:21:43:259191
</pre></div>
</div>
<p>客户端的运行日志是这样：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>Hello!<span class="w"> </span><span class="m">17</span>:21:39:253365
<span class="linenos">2</span>Hi,<span class="w"> </span>user1,<span class="w"> </span>I<span class="w"> </span>got<span class="w"> </span>you!<span class="w"> </span><span class="m">17</span>:21:40:254783
<span class="linenos">3</span>Hi,<span class="w"> </span>user2,<span class="w"> </span>I<span class="w"> </span>got<span class="w"> </span>you!<span class="w"> </span><span class="m">17</span>:21:41:256238
<span class="linenos">4</span>Hi,<span class="w"> </span>user3,<span class="w"> </span>I<span class="w"> </span>got<span class="w"> </span>you!<span class="w"> </span><span class="m">17</span>:21:42:257720
</pre></div>
</div>
<p>抓包得到的信息是这样：</p>
<figure class="align-default" id="id21">
<img alt="报文预览" src="_images/20240613_02.png" />
<figcaption>
<p><span class="caption-text">报文预览</span><a class="headerlink" href="#id21" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>报文文件下载，可以直接用 Wireshark 打开：</p>
<p><a class="reference external" href="https://github.com/junsircoding/junsircoding.github.io/blob/main/storage/20240613/learn_tcp.pcapng">learn_tcp.pcapng</a></p>
</section>
<section id="id4">
<h2>报文颜色解释<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>这里面总共有 20 条报文，他们的颜色不一样。不同的颜色代表了不同的报文类型。打开 Wireshark 的 Coloring Rules 可以看到这些每种颜色代表的含义：</p>
<figure class="align-default" id="id22">
<img alt="报文代表的含义" src="_images/20240613_03.png" />
<figcaption>
<p><span class="caption-text">报文代表的含义</span><a class="headerlink" href="#id22" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>红框圈出来的颜色就是我们的报文里涉及到的两种。其中淡紫色表示是 TCP 传输过程的报文，深灰色的表示 TCP 建立连接和关闭连接的报文。SYN 是 Synchronous 的缩写，意思是同步，表示建立连接；FIN 是 Finish 的缩写，意思是完成，表示关闭连接。</p>
<p><code class="docutils literal notranslate"><span class="pre">tcp.flags</span> <span class="pre">&amp;</span> <span class="pre">0x02</span> <span class="pre">||</span> <span class="pre">tcp.flags.fin</span> <span class="pre">==</span> <span class="pre">1</span></code> 这一段看起来有点高深。</p>
<p><code class="docutils literal notranslate"><span class="pre">tcp.flags</span></code> 是TCP报文报头的一个标志字段。TCP 报文本质上就是一行二进制数据，二进制数据就是一串 0 和 1 组成的数字串。一个 0 或 1 是 1 个比特，8 个比特是一个字节。这行二进制数据的每个位置上的数值表示固定的含义，通过查看这些值是多少就可以判断当前这个 TCP 连接的状态以及进行流量控制。下面这张图就是 TCP 报头的内容，仔细看里面有一段绿色的字写着 TCP Flags，共有 8 个标志字段，其中 S 就是 SYN ，F 就是 FIN，图的下方有标注。</p>
<figure class="align-default" id="id23">
<img alt="TCP 报文头" src="_images/20240613_04.png" />
<figcaption>
<p><span class="caption-text">TCP 报文头格式（图片来源：<a class="reference external" href="https://nmap.org/book/images/hdr/MJB-TCP-Header-800x564.png">https://nmap.org/book/images/hdr/MJB-TCP-Header-800x564.png</a>）</span><a class="headerlink" href="#id23" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">0x02</span></code> 是个十六进制数，把它转成二进制是 00000010。</p>
<p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 意思是按位与运算。遇 0 为 0，遇 1 不变。这里就是把 tcp.flags 和 00000010 做按位与运算。如果运算结果不为 0，是真值，那就表示包含 SYN 标志，是建立连接的报文。</p>
<p><code class="docutils literal notranslate"><span class="pre">tcp.flags.fin</span></code> 是一个布尔字段，表示 FIN 标志。如果这个值是 1，就表示包含 FIN 标志，是关闭连接的报文。</p>
<p><code class="docutils literal notranslate"><span class="pre">||</span></code> 是个逻辑运算符，意思是有一个条件为真，整体就为真。</p>
<p>这一长串整体的意思就是，检查这个报文是不是包含 SYN 或者 FIN 标志，如果包含任意一个，就把它标记为深灰色。</p>
</section>
<section id="id5">
<h2>报文内容解释<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<section id="id6">
<h3>三次握手建立连接<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<section id="id7">
<h4>第一次握手<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">1</span><span class="w">    </span><span class="m">0</span>.000000000<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">74</span><span class="w">      </span><span class="m">5201</span><span class="w"> </span>→<span class="w"> </span><span class="m">5200</span><span class="w"> </span><span class="o">[</span>SYN<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65495</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">MSS</span><span class="o">=</span><span class="m">65495</span><span class="w"> </span>SACK_PERM<span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1156316798</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">WS</span><span class="o">=</span><span class="m">128</span>
</pre></div>
</div>
<p>报文中每一个值的含义如下表所示：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>列号</p></th>
<th class="head"><p>内容</p></th>
<th class="head"><p>解释</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>Wireshark 捕获到的报文的帧编号</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>0.000000000</p></td>
<td><p>捕获到这个报文时的时间戳，是个相对时间，因为这个是第一个报文，所以从 0 开始</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>127.0.0.1</p></td>
<td><p>源 IP 地址</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>127.0.0.1</p></td>
<td><p>目标 IP 地址</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>TCP</p></td>
<td><p>报文的协议</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>74</p></td>
<td><p>帧的帧长度（以字节为单位），包括以太网头、IP 头、TCP 头和数据</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>5201 → 5200</p></td>
<td><p>从 5201 端口发到 5200 端口，表示是客户端发给服务端</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>[SYN]</p></td>
<td><p>标志位上 SYN 的值为 1，所以这个报文是个 SYN 报文，用于建立 TCP 连接</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>Seq=0</p></td>
<td><p>初始序号为 0</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>Win=65495</p></td>
<td><p>接收窗口大小为 65495 字节</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>len=0</p></td>
<td><p>载荷的长度是 0 字节，因为这是个 SYN 报文，不包含数据</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>MSS=65495</p></td>
<td><p>最大分段尺寸为 65495 字节</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>SACK_PERM=1</p></td>
<td><p>表示支持 SACK 选项</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>TSval=1156316798</p></td>
<td><p>时间戳值为 1156316798</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>TSecr=0</p></td>
<td><p>时间戳密钥值为 0</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>WS=128</p></td>
<td><p>窗口缩放因子为 128</p></td>
</tr>
</tbody>
</table>
<p>在 Wireshark 中用鼠标选中这条报文，在报文窗口下方的窗口会提取出详细的内容。选中 <code class="docutils literal notranslate"><span class="pre">Transmission</span> <span class="pre">Control</span> <span class="pre">Protocol</span></code> ，再点开下面的 <code class="docutils literal notranslate"><span class="pre">Flags</span></code> 选项，就可以看到每个 TCP Flags 的赋值情况。</p>
<figure class="align-default">
<img alt="TCP Flags 的赋值情况" src="_images/20240613_05.png" />
</figure>
<p>结合上面的 TCP 报头格式可以明白，标识 TCP Flags 的方式就是把对应的位置上的数字置为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<p>在这条报文中，SYN 的位置上为 1，其他位置上都是 <code class="docutils literal notranslate"><span class="pre">Not</span> <span class="pre">set</span></code> ，因此这条报文是个 SYN 报文。</p>
<p>所谓 <strong>握手</strong> ，其实就是发送一次报文。</p>
<p>双方每次收到报文都要做一件事情：</p>
<p>接收对方的 Seq 码，回复自己的 Ack 码。
A 把自己的 Seq 码发送给 B，B 收到后把这个 Seq 码 <strong>加 1 后作为 Ack 码</strong> ，再返回给 A，这就表示 B 确实已收到 A 的包。
B 回复的这个 Ack 码，也就是 A 下一个包中的 Seq 码。Ack 码的意思是，你的下一个包传来的时候，要从这个码开始。</p>
<p>在建立连接和断开连接的过程中，因为没有载荷数据，所以 Ack 都是加 1。等到建立连接后，在传输数据的过程中，Ack 就不是加 1 了，而是加载荷数据的长度。
接收端在收到多个数据包后，会对所有的数据包按照 Seq 按顺序进行重构，
这个过程中就必然会发现有缺失包，他就可以再次请求重发这个缺失包。
也就是说，根据这一来一回的 Seq 和 Ack 的偏移量，就可以保证数据传输的有序、完整。</p>
<p>在这条报文中，Seq=0，这是一个相对值。报文信息里面有一条 <code class="docutils literal notranslate"><span class="pre">Sequence</span> <span class="pre">Number</span> <span class="pre">(raw):</span> <span class="pre">1784164156</span></code> ，这个值是实际的 Seq 值，他是客户端这边随机生成的。</p>
<figure class="align-default">
<img alt="TCP 报文中的实际 Sequence Number" src="_images/20240613_06.png" />
</figure>
<p>后面客户端发送的所有报文中的 Seq 值都要在这个初始值的基础上作累加，因此这个值的相对值就是 0。</p>
<p>客户端发送完这条报文后，自己会进入一个状态，可以用 netstat 工具查看：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>netstat<span class="w"> </span>-tnp<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s1">&#39;127.0.0.1:(5200|5201)&#39;</span>

<span class="c1"># -t 仅显示 TCP 连接</span>
<span class="c1"># -n 以数字的形式</span>
<span class="c1"># -p 显示进程号</span>
<span class="c1"># grep -E 按正则筛选</span>
<span class="c1"># 127.0.0.1:(5200|5201) 筛选 5200 和 5201 这两个端口</span>
</pre></div>
</div>
<p>查看结果：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>tcp<span class="w">        </span><span class="m">0</span><span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">127</span>.0.0.1:5201<span class="w">          </span><span class="m">127</span>.0.0.1:5200<span class="w">          </span>ESTABLISHED<span class="w"> </span><span class="m">56988</span>/python3
tcp<span class="w">        </span><span class="m">0</span><span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">127</span>.0.0.1:5200<span class="w">          </span><span class="m">127</span>.0.0.1:5201<span class="w">          </span>ESTABLISHED<span class="w"> </span><span class="m">56985</span>/python3
</pre></div>
</div>
<p>这已经是三次握手结束，已经建立连接的状态了。SYN-SENT 和 SYN-RECEIVED 这两个状态持续的时间非常短，一般看不到，最常见的就是 LISTEN 、 ESTABLISHED 和 TIME-WAIT 这几个状态。</p>
<p>这张图就是三次握手的过程和状态：</p>
<figure class="align-default">
<img alt="三次握手状态" src="_images/20240613_10.png" />
</figure>
<p>这条报文的作用是： <strong>客户端生成自己的初始 Seq 码，将 Seq 标志位置为 1，向服务端发送 SYN 报文，从 CLOSED 状态进入 SYN-SENT 状态</strong> 。</p>
</section>
<section id="id8">
<h4>第二次握手<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">2</span><span class="w">    </span><span class="m">0</span>.000019926<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">74</span><span class="w">      </span><span class="m">5200</span><span class="w"> </span>→<span class="w"> </span><span class="m">5201</span><span class="w"> </span><span class="o">[</span>SYN,<span class="w"> </span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65483</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">MSS</span><span class="o">=</span><span class="m">65495</span><span class="w"> </span>SACK_PERM<span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1156316798</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1156316798</span><span class="w"> </span><span class="nv">WS</span><span class="o">=</span><span class="m">128</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="SYN-ACK 报文详细信息" src="_images/20240613_07.png" />
</figure>
<p>服务端收到上一条报文后，拿到了 Seq 值 <code class="docutils literal notranslate"><span class="pre">1784164156</span></code> ，将其加 1，作为自己的 Ack 值 <code class="docutils literal notranslate"><span class="pre">1784164157</span></code> 。
自己再随机生成一个初始 Seq 值 <code class="docutils literal notranslate"><span class="pre">2543691202</span></code> ，其相对值同样也是 0。
然后将这两个信息构造成一条 SYN-ACK 报文，返回给客户端。</p>
<p>之所以叫做 SYN-ACK 报文，就是因为它做了两件事情，一个是向客户端同步自己的 Seq 值，这是 SYN 报文，因此它的 SYN 标志位置为 1。
另一个是确认客户端的 Seq 值，这是 ACK 报文，因此它的 ACK 标志位置为 1。
这条报文是把这两个动作合到一起了。</p>
<p>这条报文的作用是： <strong>服务端收到了客户端发送的的 SYN 报文，将 Seq 码加 1 作为 Ack 码，生成自己的初始 Seq 码，将 Seq 和 Ack 两个标志位置为 1，给服务端发送一个 SYN-ACK 报文，从 LISTEN 状态进入 SYN-RECEIVED 状态</strong> 。</p>
</section>
<section id="id9">
<h4>第三次握手<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">3</span><span class="w">    </span><span class="m">0</span>.000033010<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">66</span><span class="w">      </span><span class="m">5201</span><span class="w"> </span>→<span class="w"> </span><span class="m">5200</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65536</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1156316798</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1156316798</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="第三条报文详细信息" src="_images/20240613_08.png" />
</figure>
<p>客户端收到这条报文后，拿到 Seq 值为 <code class="docutils literal notranslate"><span class="pre">2543691202</span></code> ，将其加 1，作为自己的 Ack 值 <code class="docutils literal notranslate"><span class="pre">2543691203</span></code> 。
将第二条报文中的 Ack 值作为 Seq 值 <code class="docutils literal notranslate"><span class="pre">1784164157</span></code> 。
将 ACK 标志位置为 1，构造 ACK 报文，发送给服务端。</p>
<p>这条报文的作用是： <strong>客户端收到了服务端返回的 SYN-ACK 报文，将 Seq 码加 1 作为 Ack 码，将 Ack 标志位置为 1，构造 Ack 报文发送给服务端，由 SYN-SENT 状态变为 ESTABLISHED 状态。服务端收到这条 ACK 报文后，状态由 SYN-RECEIVED 变为 ESTABLISHED 状态，连接建立</strong> 。</p>
</section>
</section>
<section id="id10">
<h3>四次挥手断开连接<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>这张图就是四次挥手的过程和状态：</p>
<figure class="align-default">
<img alt="四次挥手状态" src="_images/20240613_15.png" />
</figure>
<section id="id11">
<h4>第一次挥手<a class="headerlink" href="#id11" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">17</span><span class="w">   </span><span class="m">3</span>.005417521<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">66</span><span class="w">      </span><span class="m">5201</span><span class="w"> </span>→<span class="w"> </span><span class="m">5200</span><span class="w"> </span><span class="o">[</span>FIN,<span class="w"> </span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">22</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">50</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65536</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1136610107</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1136610107</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="第十七条报文详细信息" src="_images/20240613_11.png" />
</figure>
<p>现在是由客户端主动发起关闭动作。</p>
<p>客户端把 FIN 标志位置为 1，向服务端发动一个 FIN 包。这里的 ACK 也置为 1 了，这个 ACK 是为了回应上一步的数据传输，并不是关闭连接的逻辑，可以忽略。</p>
<p>这条报文的作用是： <strong>客户端将 FIN 标志位置为 1，构造 FIN 报文发给服务端，由 ESTABLISHED 状态变为 FIN-WAIT-1 状态</strong> 。</p>
</section>
<section id="id12">
<h4>第二次挥手<a class="headerlink" href="#id12" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">18</span><span class="w">   </span><span class="m">3</span>.046771271<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">66</span><span class="w">      </span><span class="m">5200</span><span class="w"> </span>→<span class="w"> </span><span class="m">5201</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">50</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">23</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65536</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1136610149</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1136610107</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="第十八条报文详细信息" src="_images/20240613_12.png" />
</figure>
<p>这条报文的作用是： <strong>服务端收到 FIN 报文后，告诉应用程序即将关闭，由 ESTABLISHED 状态变为 CLOSE-WAIT 状态，向客户端发送 ACK 报文。客户端收到 ACK 报文后，由 FIN-WAIT-1 状态变为 FIN-WAIT-2 状态，继续等待下一个 FIN 报文</strong> 。</p>
</section>
<section id="id13">
<h4>第三次挥手<a class="headerlink" href="#id13" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">19</span><span class="w">   </span><span class="m">4</span>.006796503<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">66</span><span class="w">      </span><span class="m">5200</span><span class="w"> </span>→<span class="w"> </span><span class="m">5201</span><span class="w"> </span><span class="o">[</span>FIN,<span class="w"> </span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">50</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">23</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65536</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1136611109</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1136610107</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="第十九条报文详细信息" src="_images/20240613_13.png" />
</figure>
<p>这条报文的作用是： <strong>应用程序准备好关闭，服务端将 FIN 标志位置为 1，向客户端发送 FIN 报文，由 CLOSE-WAIT 状态变为 LAST-ACK 状态</strong> 。</p>
</section>
<section id="id14">
<h4>第四次挥手<a class="headerlink" href="#id14" title="Link to this heading"></a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="m">20</span><span class="w">   </span><span class="m">4</span>.006834955<span class="w">     </span><span class="m">127</span>.0.0.1<span class="w">       </span><span class="m">127</span>.0.0.1<span class="w">       </span>TCP<span class="w">     </span><span class="m">66</span><span class="w">      </span><span class="m">5201</span><span class="w"> </span>→<span class="w"> </span><span class="m">5200</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">23</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">51</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">65536</span><span class="w"> </span><span class="nv">Len</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">TSval</span><span class="o">=</span><span class="m">1136611109</span><span class="w"> </span><span class="nv">TSecr</span><span class="o">=</span><span class="m">1136611109</span>
</pre></div>
</div>
<p>这条报文的详细信息如下：</p>
<figure class="align-default">
<img alt="第二十条报文详细信息" src="_images/20240613_14.png" />
</figure>
<p>这条报文的作用是： <strong>客户端收到 FIN 报文，将 ACK 标志位置为 1，向服务端发送 ACK 报文，由 FIN-WAIT-2 状态变为 TIME-WAIT 状态，等待 2 倍 MSL 的时间后，变为 CLOSED 状态断开连接。服务端收到 ACK 报文后，由 LAST-ACK 变为 CLOSED 状态，断开连接</strong> 。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MSL 全称是 Maximum Segment Life Time ，意思是 TCP 报文段在网络中能够存活的最长时间。</p>
</div>
<p>如果在 tcp_client.py 刚执行完毕后又执行一遍，会发现报这个错误：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Traceback<span class="w"> </span><span class="o">(</span>most<span class="w"> </span>recent<span class="w"> </span>call<span class="w"> </span>last<span class="o">)</span>:
<span class="w">  </span>File<span class="w"> </span><span class="s2">&quot;tcp_client.py&quot;</span>,<span class="w"> </span>line<span class="w"> </span><span class="m">9</span>,<span class="w"> </span><span class="k">in</span><span class="w"> </span>&lt;module&gt;
<span class="w">    </span>s.bind<span class="o">((</span><span class="s2">&quot;127.0.0.1&quot;</span>,<span class="w"> </span><span class="m">5201</span><span class="o">))</span>
OSError:<span class="w"> </span><span class="o">[</span>Errno<span class="w"> </span><span class="m">98</span><span class="o">]</span><span class="w"> </span>Address<span class="w"> </span>already<span class="w"> </span><span class="k">in</span><span class="w"> </span>use
</pre></div>
</div>
<p>这就是因为客户端现在处在 TIME-WAIT 状态，此时这个 TCP 连接还未完全释放，因此这个端口还不能用。大约 2 分钟之后，就可以用了。</p>
<p>用 netstat 也可以查看到：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>netstat<span class="w"> </span>-tnp<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s1">&#39;127.0.0.1:(5200|5201)&#39;</span>
tcp<span class="w">        </span><span class="m">0</span><span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">127</span>.0.0.1:5201<span class="w">          </span><span class="m">127</span>.0.0.1:5200<span class="w">          </span>TIME_WAIT<span class="w">   </span>-
</pre></div>
</div>
</section>
</section>
</section>
<section id="id15">
<h2>小结<a class="headerlink" href="#id15" title="Link to this heading"></a></h2>
<p>本文我按照自己的理解梳理了一下 TCP 协议的实际应用场景以及三次握手和四次挥手的过程，对于建立连接后的数据传输过程没有写，这块涉及的内容也不少，应该单独写一篇总结一下。TCP 作为一个基础的数据传输协议，内容有点复杂，除了基本的流程，还有性能优化的内容也需要了解。 <a class="reference external" href="https://book.douban.com/subject/1088054/">《TCP/IP 详解 卷1：协议》</a> 和 <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc793">RFC793</a> 这样的原始资料也应该看一看，后面再慢慢学习吧。</p>
</section>
<section id="id16">
<h2>参考资料<a class="headerlink" href="#id16" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）-酷壳</a></p></li>
<li><p><a class="reference external" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017788916649408">TCP编程-廖雪峰的官方网站</a></p></li>
<li><p><a class="reference external" href="https://time.geekbang.org/course/intro/100026801">Web 协议详解与抓包实战-极客时间</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=Iuvjwrm_O5g">一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手?-Youtube</a></p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="post_20240621.html" class="btn btn-neutral float-left" title="微信 Linux 版上架 Flathub 商店" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="post_20231222.html" class="btn btn-neutral float-right" title="如何在你的 Sphinx 项目中加入 plotly 图表支持？" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, junsircoding.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KTSZ2L0J1T"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KTSZ2L0J1T', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>