# Use Plotly Python to draw a heatmap and customize a non-uniform colorbar


{{< figure src="/img/20230527/20230527_avatar.en.png" title="Article cover, produced by the author through the Canva website" >}}

### Use Matplotlib to draw a filled color plot using pcolormesh

Matplotlib's [`pcolormesh`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pcolormesh.html#matplotlib.pyplot.pcolormesh) can plot two-dimensional data as a filled color plot, providing a clear visualization of the data distribution. The official documentation's [`Demo`](https://matplotlib.org/stable/gallery/images_contours_and_fields/pcolormesh_levels.html#sphx-glr-gallery-images-contours-and-fields-pcolormesh-levels-py) showcases the simple usage of this function.

```python
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(19680801) # Set a random seed to ensure that the generated Z data is the same every time.
Z = np.random.rand(6, 10) # Two-dimensional grid data with a shape of (6x10).
x = np.arange(0, 11, 1)  # x-axis coordinates with a length of 11.
y = np.arange(0, 7, 1)  # y-axis coordinates with a length of 7.

fig = plt.figure(figsize=(16, 9)) # Create a figure
ax = fig.add_subplot(111)
img = ax.pcolormesh(x, y, Z, cmap="jet") # Add a pcolormesh instance and set the cmap.
ax.set_xticks(x) # Set the x-axis coordinates.
ax.set_yticks(y) # Set the y-axis coordinates.
fig.colorbar(img, ax=ax) # Add colorbar
fig.savefig("00_test.png", bbox_inches='tight') # Execute the plot and export it as an image.
```

The generated `Z` data is as follows, with a shape of 6 rows and 10 columns:

|    |         0 |        1 |        2 |        3 |        4 |        5 |        6 |        7 |         8 |        9 |
|---:|----------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|----------:|---------:|
|  0 | 0.700367  | 0.742751 | 0.70928  | 0.566746 | 0.977785 | 0.706335 | 0.247916 | 0.157883 | 0.697699  | 0.719957 |
|  1 | 0.257744  | 0.341547 | 0.968761 | 0.694507 | 0.466383 | 0.702813 | 0.511786 | 0.928741 | 0.739769  | 0.622439 |
|  2 | 0.651545  | 0.396808 | 0.543239 | 0.7999   | 0.721545 | 0.295364 | 0.160946 | 0.206126 | 0.134325  | 0.480605 |
|  3 | 0.342522  | 0.362969 | 0.972918 | 0.110944 | 0.388264 | 0.783066 | 0.972897 | 0.48321  | 0.336421  | 0.567419 |
|  4 | 0.0479415 | 0.388937 | 0.906304 | 0.161018 | 0.743621 | 0.632974 | 0.32418  | 0.922377 | 0.237226  | 0.823946 |
|  5 | 0.750607  | 0.113784 | 0.845361 | 0.923932 | 0.220837 | 0.933054 | 0.488999 | 0.474719 | 0.0891675 | 0.229948 |

The generated image is as follows:

{{< figure src="/img/20230527/20230527_00.png" title="matplotlib pcolormesh demo" >}}

From this image, combined with the right-side `Colorbar`, we can clearly see the distribution of the data.

The current `Colorbar` is in a gradient form similar to a rainbow, and the color values are displayed as default continuous numerical values. We can make the following modifications to customize the color intervals and define colors for each interval, making the color bar display in a "discrete" form, with each interval represented as a separate segment.

```python
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import BoundaryNorm, ListedColormap # New

np.random.seed(19680801) # Set a random seed to ensure that the generated Z data is the same every time.
Z = np.random.rand(6, 10) # Two-dimensional grid data with a shape of (6x10).
x = np.arange(0, 11, 1)  # x-axis coordinates with a length of 11.
y = np.arange(0, 7, 1)  # y-axis coordinates with a length of 7.

fig = plt.figure(figsize=(16, 9)) # Create a figure
ax = fig.add_subplot(111)

# New ---
# Custom LEVEL
LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9]
# Customize the colors for each interval.
cmap = ListedColormap([ '#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000', ])  # type: ignore
norm = BoundaryNorm(LEVEL, ncolors=cmap.N, clip=True)
img = ax.pcolormesh(x, y, Z, cmap=cmap, norm=norm) # Add a pcolormesh instance and set the cmap and the norm.
ax.set_xticks(x) # Set the x-axis coordinates.
ax.set_yticks(y) # Set the y-axis coordinates.
fig.colorbar(img, ax=ax) # Add colorbar
# ---

fig.savefig("01_test.png", dpi=200, bbox_inches='tight') # Execute the plot and export it as an image.
```

{{< figure src="/img/20230527/20230527_01.png" title="matplotlib pcolormesh custom colorbar" >}}

As we can see, the `LEVEL` we have set are not continuous numerical values, but each color block has the same length. This flexibility allows us to adjust the `Colorbar` according to specific business needs and create the desired visualizations.

### Draw a heatmap filled color plot using Plotly

The plots generated by Matplotlib are static images. If we want to see the actual values in each square of the plot in real-time, how can we achieve that?

There are many libraries available for creating interactive charts that can generate HTML webpages or be displayed in real-time within Jupyter Notebook. This article introduces [`Plotly`](https://plotly.com/python/).

The corresponding counterpart to pcolormesh is the Heatmap, and the first demo mentioned earlier in the text achieves this effectï¼š

{{< plotly json="/plotly/20230527/20230527_02.json" height="500px" modebar="false" >}}

Here are the codes:

```python
import plotly.graph_objects as go
import numpy as np
np.random.seed(1)

np.random.seed(19680801) # Set a random seed to ensure that the generated Z data is the same every time.
Z = np.random.rand(6, 10) # Two-dimensional grid data with a shape of (6x10).
x = np.arange(0, 11, 1)  # x-axis coordinates with a length of 11.
y = np.arange(0, 7, 1)  # y-axis coordinates with a length of 7.

fig = go.Figure(data=go.Heatmap(
        z=Z,
        x=x,
        y=y,
        colorscale='jet'
    )
)

fig.update_layout(
    title='Plotly Heatmap Demo',
    xaxis=dict(tickvals=x, ticktext=x, title="X Axis"),
    yaxis=dict(tickvals=y, ticktext=y, title="Y Axis"),
)

fig.write_json("02_test.html")
```

This is an interactive chart created using Plotly. Hovering over each square reveals the specific numerical value, and you can freely zoom in, zoom out, as well as save the chart as an image for download, and more.

It is worth noting that the Colorbar in this chart is also continuous and rainbow-like. However, customizing the `LEVEL` for this chart is not as simple as in Matplotlib, as the implementation approaches of these two libraries are completely different.

Here are the codes:

```python
import plotly.graph_objects as go
import numpy as np
import pandas as pd


def trans_data(level: list, colors: list):
    """Transform the data
    
    Args:
        level(list): Customize the list of levels
        colors(list): Custom color list, the length should be 1 less than `level`

    Returns:
        (tuple):
            transformed data
            A list of interval values
            A hierarchical list of color scales
    """
    assert len(colors) + 1 == len(level), "the length of the `colors` should be 1 less than `level`"

    labels = np.arange(len(LEVEL)+1)
    ratio_list = np.linspace(0, 1, len(color_list)+1).tolist()

    colorscale_list = [[ratio_list[0], color_list[0]]]
    for idx, _ in enumerate(color_list[1:]):
        colorscale_list.append([ratio_list[idx+1], color_list[idx]])
        colorscale_list.append([ratio_list[idx+1], color_list[idx+1]])
    colorscale_list.append([ratio_list[-1], color_list[-1]])

    Z_cut = pd.DataFrame(pd.cut(
        Z.flatten(),
        bins=[-np.infty] + LEVEL + [np.infty],
        labels=labels
    ).reshape(Z.shape))
    return Z_cut, labels, colorscale_list


np.random.seed(19680801) # Set a random seed to ensure that the generated Z data is the same every time.
Z = np.random.rand(6, 10) # Two-dimensional grid data with a shape of (6x10).
x = np.arange(0, 11, 1)  # x-axis coordinates with a length of 11.
y = np.arange(0, 7, 1)  # y-axis coordinates with a length of 7.

LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9]
color_list = ['#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000']

Z_cut, labels, colorscale_list = trans_data(LEVEL, color_list)
Z_cut_values = np.unique(Z_cut.values.flatten())

fig = go.Figure(data=go.Heatmap(
    z=Z_cut,
    x=x,
    y=y,
    colorbar=dict(
        tickvals=np.arange(Z_cut_values.min(), Z_cut_values.max()+1),
        ticktext=LEVEL
    ),
    colorscale=colorscale_list,
    customdata=Z,
    hovertemplate='x: %{x}<br>y: %{y}<br>z:  %{customdata}<extra></extra>',
)
)

fig.update_layout(
    title='Plotly Heatmap Demo',
    xaxis=dict(tickvals=x, ticktext=x, title="X Axis"),
    yaxis=dict(tickvals=y, ticktext=y, title="Y Axis"),
)

fig.write_html("03_test.html")
```

Here's how the chart looks:

{{< plotly json="/plotly/20230527/20230527_03.json" height="500px" modebar="false" >}}


### References

[Including plotly figures in Hugo posts](https://ig248.gitlab.io/post/2018-11-05-plotly-sample/)
